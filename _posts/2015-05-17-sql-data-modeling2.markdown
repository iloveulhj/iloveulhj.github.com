---
layout: post
title:  "[SQL] 데이터 모델과 성능"
date:   2015-05-17 00:00:00
categories: jekyll update
---

이 포스트는 "SQL 전문가 가이드"의 "2장. 데이터과 성능"를 학습한 내용으로 이루어져 있습니다. 

---

# 성능 데이터 모델링의 개요

**성능 데이터 모델링이란?**  
성능 데이터 모델링이란 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것을 의미한다.

**성능 데이터 모델링 수행시점**  
성능 향상을 위한 비용은 프로젝트 수행 중에 있어서 사전에 할수록 비용이 들지 않는다. 특히 분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무 비용을 최소화 할 수 있는 기회를 가지게 된다.


**성능 데이터 모델링 고려사항**  
성능 데이터 모델링을 수행할 때 다음과 같은 프로세스로 진행하면 좋다.  
1. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.  
2. 데이터베이스 용량산정을 수행한다.  
3. 데이터베이스에 발생하는 트랜잭션의 유형을 파악한다.  
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.  
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.  
6. 성능관점에서 데이터 모델을 검증한다.

---

# 정규화와 성능

데이터 모델링을 하면서 정규화를 하는 것은 기본적으로 데이터에 대한 중복성을 제거하여 주고, 데이터가 관심사별로 처리되는 경우가 많기 때문에 성능이 향상되는 특징을 가지고 있다. 엔티티가 계속 발생되므로 SQL문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우도 있지만 이런 부분은 사례별로 유의하여 반정규화를 적용하는 전략이 필요하다.  

일반적으로 정규화가 잘 되어 있으면 입력/수정/삭제의 성능이 향상되고 반정규화를 많이 하면 조회의 성능이 향상된다고 인식한다. 그러나 데이터 모델링을 할 때 반정규화만이 조회 성능을 향상시킨다는 고정관념은 탈피되어야 한다. 정규화를 해서 성능이 저하되기는 커녕 정규화를 해야만 성능이 향상되는 경우도 있기 때문이다.

**함수적 종속성(Functional Dependency)에 근거한 정규화 수행 필요**  
함수의 종속성은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것이다. 
이 때 기준 값을 결정자(Determinant)라 하고 종속되는 값을 종속자(Dependent)라고 한다. 
함수의 종속성은 데이터가 가지고 있는 근본적인 속성으로 인식되고 있다.
정규화의 목적은 반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하기 위함이다.
그러므로 정규화는 데이터 속성간의 함수종속성에 근거하여 이루어져야 한다.

----

# 참고자료  
[데이터 베이스 정규화에 대한 기본 사항, 마이크로소프트 페이지](https://support.microsoft.com/en-us/kb/283878/ko)  

**제 1정규형**

* 개별 테이블에서 반복되는 그룹을 제거한다.
* 관련 데이터의 각 집합에 대해 별도의 테이블을 만든다.
* 기본 키를 사용하여 관련 데이터의 각 집합을 식별한다.

**제 2정규형**

* 여러 레코드에 적용되는 값 집합에 대해 별도의 테이블을 만든다.
* 이러한 테이블을 연결할 때는 외래 키를 사용한다.

**제 3정규형**

* 키에 종속되지 않는 필드를 제거한다.

---

# 반정규화와 성능

**반정규화(De-Normalization)란?**  
반정규화를 정의하면 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다. 
좁은 의미의 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 조금 더 넓은 의미의 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다.

**반정규화의 적용방법**  

방정규화를 적용할 때는 기본적으로 데이터 무결성이 깨질 가능성이 많이 있기 때문에 반드시 데이터 무결성을 보장할 수 있는 방법을 고려하여 적용해야 한다. 
정규화와 반정규화 사이에는 Trade-Off 관계로 정규화만을 강조하다 보면 성능 이슈가, 반정규화만을 강조하다 보면 데이터 무결성에 관한 이슈가 생길 수 있다.

1. 반정규화 대상 조사: 범위 처리 빈도 수 조사, 대량의 범위 처리 조사, 통계성 프로세스 조사, 테이블 조인 개수  
2. 다른 방법유도 검토: 뷰(VIEW) 테이블, 클러스터링 적용, 인덱스의 조정, 응용 어플리케이션  
3. 반정규화 적용: 테이블 반정규화, 속성의 반정규화, 관계의 반정규화 

**반정규화의 기법**  

테이블의 반정규화

| 기법 분류 | 기법 | 내용 | 
| 테이블 병합 | 1:1 관계 테이블 병합 | 1:1 관계를 통하여 성능 향상 |
| | 1:M 관계 테이블 병합 | 1:M 관계 통합하여 성능 향상  | 
| | 슈퍼/서브타입 테이블 병합 | 슈퍼/서브 관계를 통합하여 성능 향상 |
| 테이블 분할 | 수직 분할 | 칼럼 단위의 테이블을 디스크 I/O 분산처리 하기 위해 테이블을 1:1로 분리하여 성능 향상(트랜잭션 유형 파악이 선행되어야 함)
| | 수평 분할 | 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로우단위로 테이블을 쪼갬
| 테이블 추가 | 중복 테이블 추가 | 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능을 향상 | 
| | 통계 테이블 추가 | SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상 | 
| | 이력 테이블 추가 | 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재하는 방법은 반정규화의 유형 | 
| | 부분 테이블 추가 | 하나의 테이블의 전체 칼럼 중 자주 이용하는데 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성 | 

칼럼의 반정규화 

| 반정규화 기법 | 내용 |
| 중복 칼럼 추가 | 조인에 의해 처리할 때 성능 저하를 예방하기 위해 즉, 조인을 감소시키기 위해 중복된 칼럼을 위치시킴 | 
| 파생 칼럼 추가 | 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 칼럼에 보관함. Derived Column이라고 함 |
| 이력 테이블 칼럼 추가 | 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가함
| PK에 의한 칼럼 추가 | 복합 의미를 갖는 PK를 단일 속성으로 구성하였을 경우 발생됨. 단일 PK 안에서 특정 값을 별도로 조회하는 경우 성능저하가 발생될 수 있음. 이 때 이미 PK안에 데이터가 존재하지만 성능 향상을 위해 일반 속성으로 포함하는 방법 |
| 응용시스템 오작동을 위한 칼럼 추가 | 업무적으로는 의미가 없지만 사용자가 데이터처리를 하다가 잘못 처리하여 원래 값으로 복구하기를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법. 칼럼으로 이것을 보관하는 방법은 오작동 처리를 위한 임시적인 기법이지만 이것을 이력 데이터 모델로 풀어내면 정상적인 데이터 모델의 기법이 될 수 있음 | 

관계 반정규화

| 반정규화 기법 | 내용 |
| 중복관계 추가 | 데이터를 처리하기 위해 여러 경로를 거쳐 조인이 가능하지만 이 때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법이 관계의 반정규화임 | 

반정규화를 적용할 때는 데이터를 입력, 수정, 삭제할 때 성능이 떨어지고, 데이터 무결성 유지에 주의를 해야하는 점을 기억해야한다. 

---

# 대량 데이터에 따른 성능

한 테이블에 데이터가 대량으로 집중되거나 하나의 테이블에 여러 개의 칼럼이 존재하여 디스크에 많은 블록을 점유하는 경우는 모두 성능저하를 유발할 수 있다.
하나의 테이블에 대량의 데이터가 존재하는 경우 인덱스의 Tree구조가 너무 커져 효율성이 떨어져서 데이터를 처리(입력, 수정, 삭제, 조회)할 때 디스크 I/O를 많이 유발하게 된다.
또한 한 테이블에 많은 수의 칼럼이 존재하게 되면 데이터가 디스크의 여러 블록에 존재하므로 인해 디스크에서 데이터를 읽는 I/O량이 많아지게 되어 성능이 저하되게 된다.

**한 테이블에 많은 수의 칼럼을 가지고 있는 경우**  
칼럼이 수가 많은 경우는 여러 개의 디스크 블록에서 데이터를 가져와야 하므로 디스크 I/O가 많이 일어나게 된다. 
이렇게 많은 칼럼을 가지고 있는 테이블에서는 트랜잭션이 발생될 때 어떤 칼럼에 대해 집중적으로 발생하는지 분석하여 테이블을 분리하면 성능이 향상된다.

**대량 데이터 저장 및 처리로 인한 성능**  
테이블에 많은 양의 데이터가 예될 경우 파티셔닝을 적용하거나, PK에 의해 테이블을 분할하는 방법이 있다.
오라클의 경우는 LIST PARTITION(특정 값 지정), RANGE PARTITION(범위), HASH PARTITION(해쉬 적용), COMPOSITE PARTITION(범위와 해쉬가 복합) 등이 가능하다.

**테이블에 대한 수평 분할/수직 분할의 절차**
  
1. 데이터 모델링을 완성한다.
2. 데이터베이스 용량산정을 한다.
3. 대량의 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다.
4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리하는것을 검토한다.

---

# 데이터베이스 구조와 성능

**슈퍼타입/서브타입 모델(Extended ER모델)**  
슈퍼타입/서브타입 모델은 논리적인 데이터 모델에서 이용되는 형태로 분석단계에서 자주 쓰이는 모델이다.
업무를 구성하는 데이터의 특징을 공통과 차이점을 고려하여 효과적으로 표현할 수 있다.
공통의 부분을 슈퍼타입으로 모델링하고 공통으로 부터 상속받아 다른 엔티티와 차이가 있는 속성에 대해서는 별도의 서브엔티티로 구분한다.
이는 업무의 모습을 정확하게 표현사면서 물리적인 데이터 모델로 변환할 때 선택의 폭을 넓힐 수 있는 장점이 있다.
물리적인 데이터 모델을 설계하는 단계에서는 성능을 고려하여 테이블의 구조를 변환하여야 한다.
그렇지 않고 1:1로 변화하면 성능이 저하될 수 있는 위험이 있다.

슈퍼/서브 타입에 대한 변환을 잘못하는 경우는 다음과 같다.

1. 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능이 저하될 수 있다.
2. 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하될 수 있다.
3. 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하될 수 있다.

그러므로 물리적인 데이터 모델로 변활할 때는 다음과 같이 하는 것이 좋다.

1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
2. 슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입 + 서브타입 테이블로 구성
3. 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성

슈퍼/ 서브타입 데이터 모델의 변환 타입을 비교하면 다음과 같다.

| 구분 | OneToOne Type | Plus Type | Single Type |
| 특징 | 개별 테이블 유지 | 슈퍼+서브타입 테이블 | 하나의 테이블 |
| 확장성 | 우수함 | 보통 | 나쁨 |
| 조인 성능 | 나쁨 | 나쁨 | 우수함 | 
| I/O량 성능 | 좋음 | 좋음  | 나쁨 |
| 관리 용이성 | 좋지 않음 | 좋지 않음 | 좋음(1개) |
| 적합한 트랜잭션 유형 | 개별 테이블로 접근이 많은 경우 | 슈퍼+서브 형식으로 데잍러를 처리하는 경우 | 전체를 일괄적으로 처리하는 경우 | 


**인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상**  
엔티티를 설계하면 그에 따른 DDL이 생성되고, 생성된 DDL에 따라 인덱스가 생성된다.
일반적으로 PK 순서에 따라 인덱스가 자동 생성된다. 
데이터 모델링 때 결정한 PK 순서와는 다르게 DDL 문장을 통해 PK 순서를 다르게 생성할 수 있다.
하지만 대부분의 프로젝트에서 데이터 모델의 PK 순서에 따라 그대로 PK를 생성하기 때문에 임의로 변경하면 의사소통에 문제가 생길 수 있다.

PK의 순서를 인덱스 특징에 맞게 고려하지 않고 그대로 생성하게 되면, 테이블에 접근하는 트랜잭션의 특징에 효율적이지 않은 인덱스가 생성된다.
그러면 인덱스의 범위를 넓게 이용하거나 Full Scan을 유발하게 되어 성능이 저하된다고 정리할 수 있다.
그러므로 트랜잭션의 특징에 맞게 PK의 순서를 고려하는 것이 좋다.

    PK 순서의 차이 - (거래 일자 + 거래 코드), (거래 코드 + 거래 일자)
    기간과 코드를 이용해서 조회를 하게 되면 
    (거래 일자 + 거래 코드)의 경우는 넓은 범위(기간)의 인덱스 조회를 먼저 수행한다. 
    (거래 코드 + 거래 일자)는 좁은 범위(코드)로의 조회로 위의 경우보다 성능이 향상된다.
    이런 경우는 PK의 순서를 변경하거나, (거래 일자 + 거래 코드) 순서의 인덱스를 추가로 생성하는 것이 좋다.
        

**물리적인 테이블에 FK제약이 걸려있지 않을 경우 인덱스 미생성으로 성능저하**  

물리적인 테이블에 FK를 사용하지 않아도 데이터 모델 관계에 의해 상속받은 FK 속성들이 있다.
이 경우에는 SQL WHERE절에서 조인으로 이용되는 경우가 많이 있으므로 FK 인덱스를 생성해야 성능이 좋은 경우가 빈번하다.
물리적인 테이블에 FK 제약을 걸었을 때는 반드시 FK 인덱스를 생성하도록 한다.
FK 제약이 걸리지 않았을 경우에는 FK 인덱스를 생성하는 것을 기본 정책으로 하되 트랜잭션에 의해 거의 활용되지 않을 경우 삭제하도록 한다.

---

# 분산 데이터베이스와 성능  

분산 데이터베이스는 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 여러 노드로 위치시켜 사용성/성능 등을 극대화 시킨 데이터베이스를 의미한다.
분산 데이터베이스의 핵심 가치는 통합된 데이터베이스에서 제공할 수 없는 빠른 성능이다.

**분산 데이터 베이스의 투명성**  

1. 분할 투명성: 하나의 논리적 관계가 여러 단편으로 분할되어 각 단편의 사본이 여러 곳에 저장
2. 위치 투명성: 사용하려는 데이터의 저장 장소 명시 불필요. 위치 정보가 시스템 카탈로그에 유지
3. 지역사상 투명성: 지역 DBMS와 물리적 DB 사이의 매핑 보장. 각 지역시스템 이름과 무관한 이름 사용 가능
4. 중복 투명성: DB 객체가 여러 곳에 중복되어 있는지 알 필요가 없는 성질
5. 장애 투명성: 구성요소(DMBS, Computer)의 장애에 무관한 트랜잭션의 원자성 유지
6. 병행 투명성: 다수 트랜잭션 동시 수행시 결과의 일관성 유지, 타임 스탬프, 분산 2단계 락킹을 이용하여 구현

전통적인 분산 데이터베이스 구축과 같이, 분산 환경의 데이터 베이스에서 위의 특징을 모두 만족하면서 구축하는 사례는 드물다.
최근에는 분산 환경의 데이터베이스를 구축하기 보다 통합하여 데이터베이스를 구축하는 사례가 많다.
그럼에도 불구하고 업무적인 특징 및 지역적인 특징에 따라 적절하게 활용하면 다양한 장점을 제공할 수 있다.
대량의 데이터의 지역적 처리나 글로벌 처리등에서는 분산 데이터베이스가 유용하게 활용되고 있다.

**분산 데이터 베이스의 장점**  
- 지역 자치성, 점증적 시스템 용량 확장  
- 신뢰성과 가용성  
- 효용성과 융통성  
- 빠른 응답 속도와 통신비용 절감  
- 데이터의 가용성과 신뢰성 증가  
- 시스템 규모의 적절한 조절  
- 각 지역 사용자의 요구 수용 증대  

**분산 데이터 베이스의 단점**  
- 소프트웨어 개발 비용  
- 오류의 잠재성 증대  
- 처리 비용의 증대  
- 설계, 관리의 복잡성과 비용  
- 불규칙한 응답 속도  
- 통제의 어려움  
- 데이터 무결성에 대한 위협  


**분산 데이터베이스의 적용기법**  
데이터베이스의 분산의 종류에는 테이블 위치 분산, 테이블 분할 분산, 테이블 복제 분산과 테이블 요약 분산 전략이 있다.
그 중에서 가장 많이 사용하는 방식은 테이블 복제 분할 분산의 방법이다. 
이 방법은 성능이 저하되는 많은 데이터베이스에서 가장 유용하게 적용할 수 있는 기술적인 방법이 된다.

*1. 테이블 위치 분산*  
구조는 그대로 유지하되 설계된 테이블 각각이 지역별로 분산된다. 
테이블별 위치 분산은 정보를 이용하는 형태가 각 위치별로 차이가 있을 때 이용한다. 
테이블의 위치를 파악할 수 있는 도식화된 위치별 데이터베이스 문서가 필요하다. 

*2. 테이블 분할 분산*  
테이블 분할 분산은 단순히 위치만 다른 곳에 두는 것이 아니라 각각의 테이블을 쪼개어 분산하는 방법이다.
테이블을 분산하는 방법은 수평 분할(로우 단위로 분할)과 수직 분할(칼럼 단위로 분할)이 있다.

*3. 테이블 복제 분산*  
테이블 복제 분산은 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형이다.
마스터 데이터베이스에서 테이블의 일부 내용만 다른 지역이나 서버에 위치시키는 부분 복제와 
마스터 데이터베이스의 테이블의 내용을 각 지역이나 서버에 존재시키는 광역복제가 있다.
부분 복제의 경우는 지사에서 데이터에 대한 입력, 수정, 삭제가 발생하여 본사에서 이용하는 방식이 많고 
광역복제의 경우는 본사에서 데이터가 입력, 수정, 삭제가 되어 지사에서 이용하는 형태가 많다.

*4. 테이블 요약 분산*  
테이블 요약 분산은 지역간에 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우가 있다. 
요약의 방식에 따라 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 통합된 데이터를 산출하는 방식의 분석요약과 
분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식의 통합요약이 있다.

**데이터베이스 분산 설계를 하면 효과적인 경우**  
- 성능이 중요한 사이트에 적용해야 한다.  
- 공통코드, 기준정보, 마스터 데이터 등에 대해 분산환경을 구성하면 성능이 좋아진다.  
- 실시간 동기화가 요구되지 않을 때 좋다.   
- 특정 서버에 부하가 집중되어 부하를 분산할 대도 좋다.  
- 백업 사이트를 구성할 때 간단하게 분산기능을 적용하여 구성할 수 있다. 

---

출처: `"SQL 전문가 가이드, 2013 Edition", 서강수, 한국데이터베이스진흥원, 2013` 
